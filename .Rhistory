nrow(site.env19)
length(unique(cover19$Plot_id)
)
unique(cover19$Plot_id)
head(site.env19)
tail(site.env19)
g.env19 <- site.env19[,!grepl("^[C|D]+", rownames(site.env19))]
g.env19 <- site.env19[!grepl("^(C|D)", rownames(site.env19)),]
nrow(site.env19)
nrow(g.env19)
head(g.env19)
tail(g.env19)
unique(cover19$Plot_id)
setdiff(cover19$Plot_id, rownames(g.env19))
setdiff(rownames(g.env19), cover19$Plot_id)
rownames(add.plots19) <- c("1133", "3222")
add.plots19 <- rbind(c(0,0,0,0), c(0,0,0,0))
colnames(add.plots19) <- c("litter", "rock", "soil","scat")
g.env19 <- rbind(g.env19, add.plots19)
setdiff(cover19$Plot_id, rownames(g.env19))
g.env19
#calculate the mean cover of each of these items for each plot, to use as part of env in your analysis
site.env19 <- with(site.env19, tapply(Cover, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
# extract soil, organic matter, and rock from the dataset
site.env19 <- cover19[cover19$Species %in% c("soil","organic matter", "rock", "poo"),]
#calculate the mean cover of each of these items for each plot, to use as part of env in your analysis
site.env19 <- with(site.env19, tapply(Cover, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
site.env19[is.na(site.env19)] <- 0
colnames(site.env19) <- c("litter", "rock", "soil", "scat")
g.env19 <- site.env19[!grepl("^(C|D)", rownames(site.env19)),]
add.plots19 <- rbind(c(0,0,0,0), c(0,0,0,0))
rownames(add.plots19) <- c("1133", "3222")
colnames(add.plots19) <- c("litter", "rock", "soil","scat")
g.env19 <- rbind(g.env19, add.plots19)
g.env19
setdiff(cover19$Plot_id, rownames(g.env19))
# extract soil, organic matter, and rock from the dataset
site.env19 <- cover19[cover19$Species %in% c("soil","organic matter", "rock", "poo"),]
#calculate the mean cover of each of these items for each plot, to use as part of env in your analysis
site.env19 <- with(site.env19, tapply(Cover, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
site.env19[is.na(site.env19)] <- 0
colnames(site.env19) <- c("litter", "rock", "soil", "scat")
g.env19 <- site.env19[!grepl("^(C|D)", rownames(site.env19)),]
add.plots19 <- rbind(c(0,0,0,0), c(0,0,0,0), c(0,0,0,0))
rownames(add.plots19) <- c("B3333", "1133", "3222")
colnames(add.plots19) <- c("litter", "rock", "soil","scat")
g.env19 <- rbind(g.env19, add.plots19)
setdiff(cover19$Plot_id, rownames(g.env19))
nrow(g.env19)
head(g.env19)
g.env19 <- site.env19[!rowname(g.env19)=="1000",]
g.env19 <- site.env19[!rownames(g.env19)=="1000",]
g.env19
# extract soil, organic matter, and rock from the dataset
site.env19 <- cover19[cover19$Species %in% c("soil","organic matter", "rock", "poo"),]
#calculate the mean cover of each of these items for each plot, to use as part of env in your analysis
site.env19 <- with(site.env19, tapply(Cover, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
site.env19[is.na(site.env19)] <- 0
colnames(site.env19) <- c("litter", "rock", "soil", "scat")
g.env19 <- site.env19[!grepl("^(C|D)", rownames(site.env19)),]
g.env19 <- site.env19[!rownames(g.env19)=="1000",]
g.env19 <- site.env19[!grepl("^(C|D)", rownames(site.env19)),]
g.env19 <- g.env19[!rownames(g.env19)=="1000",]
nrow(g.env19)
add.plots19 <- rbind(c(0,0,0,0), c(0,0,0,0), c(0,0,0,0))
rownames(add.plots19) <- c("B3333", "1133", "3222")
colnames(add.plots19) <- c("litter", "rock", "soil","scat")
g.env19 <- rbind(g.env19, add.plots19)
nrow(g.env19)
# Subset cover data to just the focused grazing plots
g.cover19 <- cover19[cover19$Plot_id %in% rownames(g.env19),]
# Clean and reformat cover data
comm19 <- clean.comm(g.cover19)
# load tree, reformat sp names, create combined data object
tree <- read.tree("./data/Vascular_Plants_rooted.dated.tre")
tree$tip.label <- tolower(gsub("_", " ", tree$tip.label))
tree19 <- congeneric.merge(tree, colnames(comm19), split = " ")
# load in terrain variables, name rows with plot ID's, create comparative community object
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
env.d <- env.d[,c(3:6,10,12:13)]
nrow(env.d)
env.d
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
head(env.c)
rownames(env.c) <- env.c$plot_id
env.c <- env.c[,-c(1,2,10)]
head(env.c)
head(env.d)
# load in terrain variables, name rows with plot ID's, create comparative community object
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
env.d <- env.d[,c(3:6,10,12:13)]
# load in terrain variables, name rows with plot ID's, create comparative community object
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
head(env.d)
env.d <- env.d[,c(3:6,10,12:14)]
head(env.d)
# load in terrain variables, name rows with plot ID's, create comparative community object
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
head(env.d)
env.d <- env.d[,c(3:6,10,13,14,12)]
head(env.d)
head(env.c)
# clean up and add core plot data
rownames(env.c) <- env.c$plot_id
env.c <- env.c[,-c(1,2,10)]
head(env.c)
?rep_along
env.c$grazed <- rep_along(nrow(env.c),0)
head(env.c$grazed)
head(env.c)
tail(env.c)
env19 <-  merge(env.d, g.env19, by=0)
head(env19)
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
env.d <- env.d[,c(3:6,10,13,14,12)]
# clean up and add core plot data
rownames(env.c) <- env.c$plot_id
env.c <- env.c[,-c(1,2,10)]
env.c$grazed <- rep_along(nrow(env.c),0)
# combine
env.d <- rbind(env.c, env.d)
head(env.d)
head(env.c)
colnames(env.d) <- c("first", "second", "third", "fourth", "elev", "aspect", "slope", "grazed")
# clean up and add core plot data
rownames(env.c) <- env.c$plot_id
# clean up and add core plot data
rownames(env.c) <- env.c$plot_id
env.c <- env.c[,-c(1,2,10)]
env.c$grazed <- rep_along(nrow(env.c),0)
# combine
env.d <- rbind(env.c, env.d)
head(env.c)
# load in terrain variables, name rows with plot ID's, create comparative community object
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
env.d <- env.d[,c(3:6,10,13,14,12)]
colnames(env.d) <- c("first", "second", "third", "fourth", "elev", "aspect", "slope", "grazed")
# clean up and add core plot data
rownames(env.c) <- env.c$plot_id
env.c <- env.c[,-c(1,2,10)]
env.c$grazed <- rep_along(nrow(env.c),0)
# combine
env.d <- rbind(env.c, env.d)
env19 <-  merge(env.d, g.env19, by=0)
rownames(env19) <- env19$Row.names
head(env19)
env19 <- env19[,-1]
colnames(env19) <- c("first", "second", "third", "fourth","elev", "aspect", "slope", "litter", "rock", "soil")
c.data19 <- comparative.comm(tree19, comm19, env=env19)
nrow(env19)
### FOR 2019 DATA ###
# Calculate diversity metrics from abundance community data
ses.mpd19 <- .ses.mpd(c.data19)
tree19
comm19
env19
c.data19 <- comparative.comm(tree19, comm19, env=env19)
head(env19)
# load in terrain variables, name rows with plot ID's, create comparative community object
env.d <- read.csv("./data/rhf_2019_terrain_measured.csv", as.is=TRUE)
env.c <- read.csv("./data/clean_rhf_core_terrain.csv", as.is=TRUE)
# clean terrain data
# transform aspect
env.d$m_cos_asp <- with(env.d, cos.transform(Aspect_deg))
# calculate slope
env.d$slope_deg <- with(env.d, calc.slope(Slope_down_deg, Slope_up_deg))
# trim the data to what you'll use
rownames(env.d) <- env.d$Plot_id
# separate plot_id - for spatially explicit analysis
env.d <- env.d %>% extract(Plot_id, c("first", "second", "third", "fourth"), "([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)([[:digit:]]+)", remove = FALSE)
env.d <- env.d[,c(3:6,10,13,14,12)]
colnames(env.d) <- c("first", "second", "third", "fourth", "elev", "aspect", "slope", "grazed")
# clean up and add core plot data
rownames(env.c) <- env.c$plot_id
env.c <- env.c[,-c(1,2,10)]
env.c$grazed <- rep_along(nrow(env.c),0)
head(env.c)
head(env.d)
# combine
env <- rbind(env.c, env.d)
head(env)
head(g.env19)
env19 <-  merge(env, g.env19, by=0)
head(env19)
rownames(env19) <- env19$Row.names
env19 <- env19[,-1]
head(env19)
c.data19 <- comparative.comm(tree19, comm19, env=env19)
### FOR 2019 DATA ###
# Calculate diversity metrics from abundance community data
ses.mpd19 <- .ses.mpd(c.data19)
ses.mntd19 <- .ses.mntd(c.data19)
pd19 <- .pd(c.data19)
simps.div19 <- diversity(c.data19$comm, index="simpson")
# Compile metrics into a data frame with environmental information
data19 <- cbind(c.data19$env, ses.mpd19$ntaxa, ses.mpd19$mpd.obs.z, ses.mntd19$mntd.obs.z, pd19[,1], simps.div19)
head(data19)
# Subset the data into different triad levels
one19 <- subset.first.level(data19)
two19 <- subset.second.level(data19)
three19 <- subset.third.level(data19)
# SES_mpd (z)
mpd19all <- with(data19, lm(sesmpd ~ (elev+slope+aspect+litter+rock+soil)*grazed) #NS
)
head(data19)
colnames(data19) <- c("first", "second", "third", "fourth","elev", "aspect", "slope", "grazed", "litter","rock","soil", "scat", "ntaxa", "sesmpd", "sesmntd", "pd", "simpsdiv")
# Subset the data into different triad levels
one19 <- subset.first.level(data19)
two19 <- subset.second.level(data19)
three19 <- subset.third.level(data19)
# Species richness
nsp19all <- with(data19, lm(ntaxa ~ (elev+slope+aspect+litter+rock+soil)*grazed) #NS
)
summary(nsp19all)
# SES_mpd (z)
mpd19all <- with(data19, lm(sesmpd ~ (elev+slope+aspect+litter+rock+soil)*grazed)) #NS
# Species richness
nsp19all <- with(data19, lm(ntaxa ~ (elev+slope+aspect+litter+rock+soil+scat)*grazed)) #NS
# SES_mpd (z)
mpd19all <- with(data19, lm(sesmpd ~ (elev+slope+aspect+litter+rock+soil+scat)*grazed)) #NS
summary(nsp19all)
summary(mpd19all)
# SES_mntd (z)
mntd19all <- with(data19, lm(sesmntd ~ (elev+slope+aspect+litter+rock+soil+scat)*grazed) # slope (p-value=0.009) and rock (p-value=0.031) significant
)
summary(mntd19all)
# Faith's PD
pd19all <- with(data19, lm(pd ~ (elev+slope+aspect+litter+rock+soil+scat)*grazed)) #NS
summary(pd19all)
# Simpson's Div ####
simpsdiv19all <- with(data19, lm(simpsdiv ~ (elev+slope+aspect+litter+rock+soil+scat)*grazed) # litter (p-value = 0.051) significant
)
summary(simpsdiv19all)
# Temperature correction function for hydrometer readings (+0.4 g/L for each degree above 20 C, - 0.4 g/L for each degree below 20 C)
temp.correct <- function(temp, hydro_rdg){
return(hydro_rdg + ((temp-20)*0.4))
}
# set working directory to location on your computer
setwd("~/Documents/projects/")
# load in soil data
soil18<- read.csv("./soil_analysis_rhf/data/rhf_2018_soil_texture.csv", as.is=TRUE)
soil19 <- read.csv("./soil_analysis_rhf/data/rhf_2019_soil_texture.csv", as.is=TRUE)
soil19
soil19
soil18
# remove plots with goof
soil18 <- na.omit(soil18)
soil19 <- na.omit(soil19)
# this function does all the arithmatic
texture <- function(plot_ID, soil_wt, temp_calib, hydro_calib, temp_40, hydro_40, temp_120, hydro_120){
clean_soil <- matrix(nrow=nrow(soil), ncol=4)
colnames(clean_soil) <- c("plot_ID", "SAND", "CLAY", "SILT")
clean_soil[,1] <- as.numeric(plot_ID)
for(i in 1:nrow(soil)){
B <- with(soil, temp.correct(temp_calib[i], hydro_calib[i]))
A_40 <- with(soil, temp.correct(temp_40[i], hydro_40[i]))
A_120 <- with(soil, temp.correct(temp_120[i], hydro_120[i]))
silt_clay <- ((A_40-B)/soil_wt[i])*100
clean_soil[i,2] <- as.numeric(100-silt_clay) #sand
clean_soil[i,3] <- as.numeric(((A_120-B)/soil_wt[i])*100) #clay
clean_soil[i,4] <- as.numeric(100 - (100-silt_clay) - (((A_120-B)/soil_wt[i])*100)) #silt
}
return(clean_soil)
}
text18 <- as.data.frame(with(soil, texture(plot_ID, soil_wt, temp_calib, hydro_calib, temp_40, hydro_40, temp_120, hydro_120)))
text18 <- as.data.frame(with(soil18, texture(plot_ID, soil_wt, temp_calib, hydro_calib, temp_40, hydro_40, temp_120, hydro_120)))
head(soil18)
head(soil19)
text18 <- as.data.frame(with(soil18, texture(soil18, plot_ID, soil_wt, temp_calib, hydro_calib, temp_40, hydro_40, temp_120, hydro_120)))
### Clean & combine all trait data into one data set ###
### Elizabeth Simpson 2021-03-24 ######################
setwd("~/Documents/projects/functional_traits_rhf")
library("plyr")
#library("dplyr")
# EQ. to convert pixels to mm: pixels/(DPI:inch/pixels)*25.3mm/inch
pix2mm <- function(pixels, DPI){
mm.out <- NA
for(i in seq_along(pixels)){
mm.out[i] <- (pixels[i]/DPI)*25.4
}
return(mm.out)
}
### lOAD LEAF & HEIGHT DATA ###
# Leaf area - old scanner - 300 dpi
LA.os <- rbind(read.delim("./analysis_code/stalkless-take2/rhf_old_scan_plus-sd-mult-1_3/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_old_scan_plus-sd-div-2/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_old_scan_plus-sd/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_old_scan_just-mean/statistics.txt"))
# Leaf area - new scanner - 600 dpi
LA.ns <- rbind(read.delim("./analysis_code/stalkless-take2/rhf_new_scan_plus-sd-mult-1_3/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_new_scan_plus-sd-div-2/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_new_scan_minus-sd-div-3_5/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_new_scan_minus-sd-div-2/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_new_scan_minus-sd/statistics.txt"),
read.delim("./analysis_code/stalkless-take2/rhf_new_scan_just-mean/statistics.txt"))
# Leaf mass
mass18 <- read.csv("./raw_data/rhf_2018_traits_sla_leaf_mass.csv", as.is=TRUE)
mass19 <- read.csv("./raw_data/rhf_2019_traits_sla_leaf_mass.csv", as.is=TRUE)
# Height
ht18 <- read.csv("./raw_data/rhf_2018_traits_height.csv", as.is=TRUE)
ht19 <- read.csv("./raw_data/rhf_2019_traits_height.csv", as.is=TRUE)
# Collection notes
col.notes <- read.csv("./raw_data/SLA-collection-notes.csv", as.is=TRUE)
##############################
### LEAVES - SLA, LA, LDMC ###
##############################
#####################################
### LEAF AREA : Clean and combine ###
# Convert surface.area pixels to mm
LA.os$sa.mm <- pix2mm(LA.os$surface.area, 300)
LA.ns$sa.mm <- pix2mm(LA.ns$surface.area, 600)
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
# CONVERT ANY OTHER OF THESE THAT YOU DECIDE TO USE TO mm #
# combine them
area.stat <- rbind(LA.os, LA.ns)
# Give each individual a unique identifier across rows of data (multiple scans), called summary name (sum.name)
# Note to self: Your naming strategy made this unnecessarily complicated.
area.stat$sum.name <- NA
for (i in seq_len(nrow(area.stat))){
if (grepl("^[A-D]", area.stat$original.file[i])){
area.stat$sum.name[i] <- substr(area.stat$original.file[i], start=1,stop=8)
} else if (grepl("\\d{2}-\\d{4}-\\d{2}", area.stat$original.file[i])){
area.stat$sum.name[i] <- substr(area.stat$original.file[i], start=1,stop=11)
} else if (grepl("\\d{2}-\\d{4}-\\d", area.stat$original.file[i])){
area.stat$sum.name[i] <- substr(area.stat$original.file[i], start=1,stop=10)
} else if (grepl("\\d{4}-\\d{2}", area.stat$original.file[i])){
area.stat$sum.name[i] <- substr(area.stat$original.file[i], start=1,stop=8)
} else {
area.stat$sum.name[i] <- substr(area.stat$original.file[i], start=1,stop=7)
}
}
# Calculate the total leaf area for each individual based on sum.name
# Includes all leaves + scans for each individual
area.indv <- as.data.frame(with(area.stat, tapply(sa.mm, sum.name, sum)))
area.indv$indv <- row.names(area.indv)
colnames(area.indv) <- c("t_sa", "indv")
######################################################
### LEAF MASS : Clean and combine (with leaf area) ###
# Combine 2018 + 2019 leaf mass, trip to columns: N_leaves, Species, Bag_label [=indv], Leaf_mass_g, Petiole_mass_g
ldmc <- rbind(mass18[,c(4:6,9:10)], mass19[,c(4:5,7,11:12)])
# Give each individual a unique code
ldmc$indv <- NA
for (i in seq_len(nrow(ldmc))){
if (grepl("^[A-D]", ldmc$Bag_label[i])){
ldmc$indv[i] <- substr(ldmc$Bag_label[i], start=1,stop=8)
} else if (grepl("\\d{2}-\\d{4}-\\d{2}", ldmc$Bag_label[i])){
ldmc$indv[i] <- substr(ldmc$Bag_label[i], start=1,stop=11)
} else if (grepl("\\d{2}-\\d{4}-\\d", ldmc$Bag_label[i])){
ldmc$indv[i] <- substr(ldmc$Bag_label[i], start=1,stop=10)
} else if (grepl("\\d{4}-\\d{2}", ldmc$Bag_label[i])){
ldmc$indv[i] <- substr(ldmc$Bag_label[i], start=1,stop=8)
} else {
ldmc$indv[i] <- substr(ldmc$Bag_label[i], start=1,stop=7)
}
}
# DECISION --> Combine petiole and leaf mass into total mass
ldmc$t_mass <- NA
for(i in seq_len(nrow(ldmc))){
ldmc$t_mass[i]<- with(ldmc, Leaf_mass_g[i]+Petiole_mass_g[i])
}
# Calculate number of leaves, total mass, and the ldmc for each individual (sometimes multiple rows in the mass data sheet (L5/RF for example))
N_leaves <- as.data.frame(with(ldmc, tapply(N_leaves, indv, sum)))
t_mass <- as.data.frame(with(ldmc, tapply(t_mass, indv, sum)))
species <- as.data.frame(with(ldmc, tapply(Species, indv, unique)))
ldmc.indv <- cbind(species, N_leaves, t_mass)
ldmc.indv$indv <- rownames(ldmc.indv)
colnames(ldmc.indv) <- c("species", "N_leaves", "t_mass", "indv")
# Put all the leaf traits together and calculate SLA for all INDIVIDUALS
sla.indv <- merge(ldmc.indv, area.indv, by.x="indv", by.y="indv")
sla.indv$i_mass <- NA
sla.indv$i_sa <- NA
sla.indv$i_sla <- NA
for(i in seq_len(nrow(sla.indv))){
sla.indv$i_mass[i]<- with(sla.indv, t_mass[i]/N_leaves[i])
sla.indv$i_sa[i] <- with(sla.indv, t_sa[i]/N_leaves[i])
sla.indv$i_sla[i] <-with(sla.indv, i_sa[i]/i_mass[i])
}
# DECISION - Filter to only be the best collection for each species
# need to remove letter off the end of each indv id to aggregate to species
for (i in seq_len(nrow(sla.indv))){
sla.indv$sp.ID[i] <- substr(sla.indv$indv[i], start=1,stop=nchar(sla.indv$indv[i])-1)
}
# subset species by chosen best collection from the collection notes
sla.indv <- sla.indv[sla.indv$sp.ID %in% col.notes$best_collection,]
# Summarize leaf traits (mean and variation) for each species based on number of observations for each species
sla.mean <- as.data.frame(with(sla.indv, tapply(i_sla, species, mean)))
la.mean <- as.data.frame(with(sla.indv, tapply(i_sa, species, mean)))
ldmc.mean <- as.data.frame(with(sla.indv, tapply(i_mass, species, mean)))
sla.sd <- as.data.frame(with(sla.indv, tapply(i_sla, species, sd)))
la.sd <- as.data.frame(with(sla.indv, tapply(i_sa, species, sd)))
ldmc.sd <- as.data.frame(with(sla.indv, tapply(i_mass, species, sd)))
total.N <- as.data.frame(with(sla.indv, tapply(N_leaves, species, sum)))
mean.N <- as.data.frame(with(sla.indv, tapply(N_leaves, species, mean)))
leaf.traits <- cbind(sla.mean, la.mean, ldmc.mean, sla.sd, la.sd, ldmc.sd, total.N, mean.N)
colnames(leaf.traits) <- c("sla.m", "la.m", "ldmc.m", "sla.sd", "la.sd", "ldmc.sd", "N.total", "N.m")
# DECISION: calculate variation in traits based on total number of leaves measured
# (Instead of mean number of leaves collected from each individual)
leaf.traits$sla.se <- NA
leaf.traits$la.se <- NA
leaf.traits$ldmc.se <- NA
for(i in seq_len(nrow(leaf.traits))){
leaf.traits$sla.se[i]<- with(leaf.traits, sla.sd[i]/sqrt(N.total[i]))
leaf.traits$la.se[i] <- with(leaf.traits, la.sd[i]/sqrt(N.total[i]))
leaf.traits$ldmc.se[i] <-with(leaf.traits, ldmc.sd[i]/sqrt(N.total[i]))
}
leaf.traits <- leaf.traits[,c(1:3,9:11)] # Cut out SD and N info
leaf.traits <- na.omit(leaf.traits) #only removes one species right now, for 137 sp. total
##############
### HEIGHT ###
##############
# Making RHF height data long form - from Will Pearse, 2018-10-29 #
# Combining 2018-2019 height data - Elizabeth Simpson,  2019-07-31
########################
### 2018 Height Data ###
# Magic matrix --> numeric conversion trick
subset <- t(as.matrix(ht18[,-1:-7]))
heights <- as.numeric(subset)
# Expand the original data to match (dropping unneeded columns)
expanded.ht18 <- ht18[rep(1:nrow(ht18), each=25),]
expanded.ht18 <- expanded.ht18[,1:7]
# Match up the two
expanded.ht18$height <- heights
expanded.ht18 <- na.omit(expanded.ht18)
expanded.ht18 <- expanded.ht18[,-7]
rownames(expanded.ht18) <- seq_along(1:nrow(expanded.ht18))
# load in 2019 data (recorded in long form), match columns to 2018 data
ht19 <- ht19[,1:7]
colnames(ht19)[7] <- "height"
# put all height together
all.height <- rbind(expanded.ht18, ht19)
#some height metrics
ht.max <- as.data.frame(with(all.height, tapply(height, Species, max)))
ht.mean <- as.data.frame(with(all.height, tapply(height, Species, mean)))
ht.sd <- as.data.frame(with(all.height, tapply(height, Species, sd)))
ht.N <- count(all.height, "Species")
ht.traits <- cbind(ht.max, ht.mean, ht.sd, ht.N$freq)
colnames(ht.traits) <-c("ht.max", "ht.m", "ht.sd", "ht.N")
ht.traits$ht.se <- NA
for(i in seq_len(nrow(ht.traits))){
ht.traits$ht.se[i]<- with(ht.traits, ht.sd[i]/sqrt(ht.N[i]))
}
ht.traits <- ht.traits[,c(1:2,5)] # remove sd and N info
ht.traits <- na.omit(ht.traits) # removes 8 species for 132 species total
#############################################
### PUT ALL THE LEAF & HT traits together ###
#############################################
leaf.traits$species <- rownames(leaf.traits)
ht.traits$species <- rownames(ht.traits)
#setdiff(rownames(leaf.traits),rownames(ht.traits))
#setdiff(rownames(ht.traits), rownames(leaf.traits))
all.traits <- merge(leaf.traits, ht.traits, by.x="species", by.y="species")
head(all.traits)
nrow(all.traits)
