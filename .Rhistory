env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(unlist(env, div))
}
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40,noise.y=20, 100)
test.mtn
str(test.mtn)
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(list(env, div))
}
str(test.mtn)
test.div <- make.div(wavy.grad, test.par) # makes 64 different landscapes
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40,noise.y=20, 100)
str(test.mtn)
test.mtn[1]
str(test.mtn[1])
str(test.mtn[2])
#### TESTING THINGS ###
par.test <- data.frame(expand.grid(Ax = seq(0, 10, by=10), Ay = seq(0, 10, by=10),
Bx = seq(0, 0.25, by=0.25), By = seq(0, 0.25, by=0.25),
slope = seq(-6,6, by=4), int = seq(10,10, by=10),
noise.x = seq(0, 100, 100), noise.y=seq(0, 100, 100),
d=d))
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40,noise.y=20, 100)
str(test.mtn)
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)
str(test.mtn[1])
str(test.mtn[2])
test.div <- test.mtn[2]
test.env <- test.mtn[1]
test.env
str(test.env)
test.env <- unlist(test.mtn[1])
test.div <- unlist(test.mtn[2])
test.env
str(test.env)
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)
str(test.mtn)
unlist(test.mtn)
test.env <- as.matrix(unlist(test.mtn[1]))
str(test.env)
d <- 100
test.env <- matrix(unlist(test.mtn[1]),nrow=d,ncol=d)
str(test.env)
test.env <- matrix(test.mtn[1],nrow=d,ncol=d)
str(test.env)
test.env <- matrix(unlist(test.mtn[1]),nrow=d,ncol=d)
str(test.env)
test.div <- matrix(unlist(test.mtn[2]),nrow=d,ncol=d)
test.div
str(test.div)
# for each row of parameters, using a land generation thing
test.mtn <- matrix(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]),nrow=d,nrow=d)
mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]
str(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1])
unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1])
str(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]))
# for each row of parameters, using a land generation thing
str(matrix(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]),nrow=d,nrow=d))
# for each row of parameters, using a land generation thing
str(matrix(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]),nrow=d,ncol=d))
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <- with(params, matrix(unlist(land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1]), nrow=d[i], ncol=d[i]))
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1])), nrow=d[i], ncol=d[i])
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(list(env, div))
}
# Wavy-linear gradient
wavy.grad <-function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- (i+(Ax*cos(Bx*i)))+(j+(Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x) #completely random variation in x but still deterministic of y
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y) #completely random variation in y
}
}
return(list(env, div))
}
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1])), nrow=d[i], ncol=d[i])
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1])), nrow=d, ncol=d)
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
str(test.mult.env)
par.test
str(par.test)
make.div <- function(land.gen, params){
div <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
div[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[2])), nrow=d, ncol=d)
}
return(div)
}
test.mult.div <- make.div(wavy.grad, par.test)
str(test.mult.div)
str(test.mult.env)
str(params)
str(test.params)
str(test.par)
str(par.test)
mtn.coefs <- c(2.2945, 2.2945+0.0004, 2.2945+0.0031, 2.2945+1.6629, 2.2945+0.4519, 2.2945+0.0482, 2.2945-3.9247, 2.2945+2.2516, 2.2945+0.1675, 2.2945+0.0433, 2.2945-0.1026)
# function for making each coefficient in logistic regression output a proportion
inv.logit <- function(x) exp(x)/(exp(x)+1)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
mtn.coefs <- c(2.7027, 2.7027+0.0038, 2.7027-0.0140, 2.7027-0.2396, 2.7027+1.8768, 2.7027+0.0133, 2.7027-2.0104, 2.7027+0.5291, 2.7027+0.0365, 2.7027-0.1722, 2.7027-0.1722)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
mtn.coefs <- c(2.4881, 2.4881-0.0007, 2.4881+0.0107, 2.4881-0.9970, 2.4881+0.1068, 2.4881-0.0147, 2.4881-3.6243, 2.4881+2.5654, 2.4881+0.0072, 2.4881-0.0647, 2.4881-0.2890)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
mtn.coefs <- c(3.0177, 3.0177-0.0010, 3.0177-0.0127, 3.0177-1.0939, 3.0177-1.0747, 3.0177-0.0000, 3.0177-1.9250, 3.0177+0.9692, 3.0177+0.0331, 3.0177-0.2573, 3.0177-0.2573)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
2916*2
###########
# HEADERS #
###########
library(pez)
library(vegan)
library(lme4)
library(visreg) # need to load this package to plot loaded .Rdata
?.ses.mpd
library(rstanarm)
citation(rstanarm)
?citation
citation("rstanarm")
citation("vegan")
dljfsldfs
dkfjdk'fjdsl'
setwd("~/Documents/projects/functional_traits_rhf") # uncomment to set working directory on computer
###########
# HEADERS
library(pez)
library(FD)
library(lme4)
library(soiltexture)
library(car)
################
# COMMUNITY DATA
# load in cover data, reformat, remove NAs, remove species essentially there as notes
cover <- read.csv("./raw_data/rhf_2018_cover.csv", as.is=TRUE)
# Add in overhanging cover
cover$Cover.over <- NA
for (i in seq_len(nrow(cover))){
if (with(cover, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover$Cover.over[i] <- cover$Cover[i]
}
}
comm <- with(cover, tapply(Cover.over, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
comm[is.na(comm)] <- 0
comm <- comm[, colSums(comm != 0) > 0]
comm <- comm[,!grepl("^[a-z]+", colnames(comm))]
comm <- comm[,!grepl("\\(|/", colnames(comm))]
comm <- comm[,!grepl("sp\\.", colnames(comm))]
colnames(comm) <- tolower(colnames(comm))
################################
# PHYLOGENY (Zanne et. al. 2014)
# load tree, reformat sp names, create combined data object
tree <- read.tree("./clean_data/Vascular_Plants_rooted.dated.tre")
tree$tip.label <- tolower(gsub("_", " ", tree$tip.label))
tree <- congeneric.merge(tree, colnames(comm), split = " ")
#################################
# ENVIRONMENTAL DATA - topography, terrain, texture, for the 25 plots with temp & soil texture data
env <- read.csv("./clean_data/temp-texture-terrain-18.csv", as.is=TRUE)
rownames(env) <- env$plot_id
env <- env[,c(3:17)]
############
# TRAIT DATA
# Focusing analysis on continuous variables and means for each leaf and height traits
# Keeping dispersal syndrome and native vs. not for a supplementary analysis
traits <- read.csv("./clean_data/clean_traits_rhf.csv", as.is=TRUE)
rownames(traits) <- tolower(traits$species)
traits <- traits[,c(3:5,9:10)]
head(comm)
head(env)
head(traits)
###################################
# Make comparative community object
c.data <- comparative.comm(tree, comm, traits=traits, env=env)
str(c.data)
c.data
#####################################################################
# Calculate functional, phylogenetic, and taxonomic diversity indices
# Focus on functional dispersion and community weighted means but the 3 Villeger et al. 2008 indicies are also in here
funct.div.c.m <- with(c.data, dbFD(data, comm, w.abun=TRUE, stand.x=TRUE))
funct.div.c.m
colSums(comm != 0)
colSums(comm != 0) > 0
length(colSums(comm != 0) > 0)
################
# COMMUNITY DATA
# load in cover data, reformat, remove NAs, remove species essentially there as notes
cover <- read.csv("./raw_data/rhf_2018_cover.csv", as.is=TRUE)
head(cover)
rm(list=ls())
cover <- read.csv("./raw_data/rhf_2018_cover.csv", as.is=TRUE)
tree <- read.tree("./clean_data/Vascular_Plants_rooted.dated.tre")
env <- read.csv("./clean_data/temp-texture-terrain-18.csv", as.is=TRUE)
traits <- read.csv("./clean_data/clean_traits_rhf.csv", as.is=TRUE)
### CLEAN DATA ###
# Community data - reformat, remove NAs, remove species essentially there as notes
# Add in overhanging cover
cover$Cover.over <- NA
for (i in seq_len(nrow(cover))){
if (with(cover, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover$Cover.over[i] <- cover$Cover[i]
}
}
head(cover)
head(env)
length(unique(cover$Plot_id))
length(unique(env$plot_id))
# subset by environmental data so you don't end up with species with no abundances in the final dataset
cover <- cover[cover$Plot_id %in% env$plot_id,]
length(unique(cover$Plot_id))
# reformat, remove NAs, remove species essentially there as notes
comm <- with(cover, tapply(Cover.over, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
comm[is.na(comm)] <- 0
comm <- comm[, colSums(comm != 0) > 0]
comm <- comm[,!grepl("^[a-z]+", colnames(comm))]
comm <- comm[,!grepl("\\(|/", colnames(comm))]
comm <- comm[,!grepl("sp\\.", colnames(comm))]
colnames(comm) <- tolower(colnames(comm))
################################
# PHYLOGENY (Zanne et. al. 2014) - reformat sp names, create combined data object
tree$tip.label <- tolower(gsub("_", " ", tree$tip.label))
tree <- congeneric.merge(tree, colnames(comm), split = " ")
#################################
# ENVIRONMENTAL DATA - topography, terrain, texture, for the 25 plots with temp & soil texture data
rownames(env) <- env$plot_id
env <- env[,c(3:17)]
############
# TRAIT DATA - Focusing analysis on continuous variables and means for each leaf and height traits
# Also have some categorical traits that could be intersting...dispersal syndrome, native vs. not, etc...
rownames(traits) <- tolower(traits$species)
traits <- traits[,c(3:5,9:10)]
###################################
# Make comparative community object
c.data <- comparative.comm(tree, comm, traits=traits, env=env)
#####################################################################
# Calculate functional, phylogenetic, and taxonomic diversity indices
# Focus on functional dispersion and community weighted means but the 3 Villeger et al. 2008 indicies are also in here
funct.div.c.m <- with(c.data, dbFD(data, comm, w.abun=TRUE, stand.x=TRUE))
ses.mpd.a <- .ses.mpd(c.data, abundace.weighted=TRUE)
ses.mntd.a <- .ses.mntd(c.data, abundance.weighted=TRUE)
pd <- .pd(c.data)
simps.div <- diversity(c.data$comm, index="simpson")
fdiv.c.m <- with(funct.div.c.m, cbind(FDis, CWM, nbsp, ses.mpd.a$mpd.obs.z, ses.mntd.a$mntd.obs.z, pd[,1], simps.div))
head(fdiv.c.m)
fdiv.c.m$plot_id <- rownames(fdiv.c.m)
#####################################################################
# Calculate functional, phylogenetic, and taxonomic diversity indices
# Focus on functional dispersion and community weighted means but the 3 Villeger et al. 2008 indicies are also in here
f.div <- with(c.data, dbFD(data, comm, w.abun=TRUE, stand.x=TRUE))
ses.mpd.a <- .ses.mpd(c.data, abundace.weighted=TRUE)
div <- with(f.div, cbind(FDis, CWM, nbsp, ses.mpd.a$mpd.obs.z, ses.mntd.a$mntd.obs.z, pd[,1], simps.div))
colnames(div) <- c("fdis","CWM.SLA","CWM.LA","CWM.odw", "CWM.maxht", "CWM.mn.ht","nsp", "sesmpd","sesmntd", "pd", "simpsdiv")
head(div)
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(s.fd.c.m, lm(mean~elev+aspect+slope)) # yes, across aspect
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope)) # yes, across aspect
head(div)
str(c.data)
head(c.data$env)
head(div)
div <- cbind(div, c.data$env)
head(div)
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope)) # yes, across aspect
min <- with(div, lm(min~elev+aspect+slope)) # no
max <- with(div, lm(max~elev+aspect+slope)) # yes, across aspect
sd <- with(div, lm(sd~elev+aspect+slope)) # yes, across aspect
sand <- with(div, lm(SAND~elev+aspect+slope))
silt <- with(div, lm(SILT~elev+aspect+slope))
clay <- with(div, lm(CLAY~elev+aspect+slope))
summary(mean)
summary(min)
summary(sd)
summary(max)
summary(sand)
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope+sand+silt+clay)) # yes, across aspect
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope+SAND+SILT+CLAY)) # yes, across aspect
summary(mean)
vif(mean)
with(div, cor(mean, SAND, method = "pearson"))
with(div, cor(mean, SILT, method = "pearson"))
with(div, cor(mean, CLAY, method = "pearson"))
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope+SAND+CLAY)) # yes, across aspect
vif(mean)
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope+CLAY)) # yes, across aspect
vif(mean)
summary(mean)
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope+SILT)) # yes, across aspect
summary(mean)
###################################################################
# Do temperature and soil texture vary systematically across environment?
mean <- with(div, lm(mean~elev+aspect+slope+SAND+SILT+CLAY)) # yes, across aspect
summary(mean)
with(div, cor(mean, SAND, method = "pearson"))
with(div, cor(mean, SILT, method = "pearson"))
with(div, cor(mean, CLAY, method = "pearson"))
mean <- with(div, lm(mean~elev+aspect+slope+CLAY)) # yes, across aspect
summary(mean)
with(div, cor(sd, SAND, method = "pearson"))
with(div, cor(sd, SILT, method = "pearson"))
with(div, cor(sd, CLAY, method = "pearson"))
sd <- with(div, lm(sd~elev+aspect+CLAY)) # yes, across aspect
summary(sd)
vif(sd)
with(div, cor(min, SAND, method = "pearson"))
with(div, cor(min, SILT, method = "pearson"))
with(div, cor(min, CLAY, method = "pearson"))
min <- with(div, lm(min~elev+aspect+slope+CLAY)) # no
summary(min)
mean <- with(div, lm(mean~elev+aspect*slope+CLAY)) # yes, across aspect
summary(mean)
mean <- with(div, lm(mean~CLAY+elev+slope+aspect)) # yes, across aspect
summary(mean)
mean <- with(div, lm(mean~aspect+slope+elev+CLAY)) # yes, across aspect
summary(mean)
mean <- with(div, lm(mean~elev+aspect+slope+CLAY)) # yes, across aspect
sd <- with(div, lm(sd~elev+aspect+slope+CLAY)) # yes, across aspect
min <- with(div, lm(min~elev+aspect+slope+CLAY)) # no
with(div, cor(min, SAND, method = "pearson"))
with(div, cor(min, SILT, method = "pearson"))
with(div, cor(min, CLAY, method = "pearson"))
with(div, cor(max, SAND, method = "pearson"))
with(div, cor(max, SILT, method = "pearson"))
with(div, cor(max, CLAY, method = "pearson"))
sand <- with(div, lm(SAND~elev+aspect+slope)) # no
silt <- with(div, lm(SILT~elev+aspect+slope)) #
clay <- with(div, lm(CLAY~elev+aspect+slope))
summary(sand)
summary(silt)
summary(clay)
sand <- with(div, lm(SAND~elev)) # no
summary(sand)
silt <- with(div, lm(SILT~elev)) #
summary(silt)
clay <- with(div, lm(CLAY~elev))
summary(clay)
+aspect+slope
clay <- with(div, lm(CLAY~elev+aspect+slope))
summary(clay)
clay <- with(div, lm(CLAY~elev*aspect*slope))
summary(clay)
clay <- with(div, lm(CLAY~elev*slope))
summary(clay)
clay <- with(div, lm(CLAY~elev))
summary(clay)
mean <- with(div, lm(mean~elev+aspect+slope*CLAY)) # yes, across aspect
sd <- with(div, lm(sd~elev+aspect+slope*CLAY)) # yes, across aspect
min <- with(div, lm(min~elev+aspect+slope*CLAY)) # no
max <- with(div, lm(max~elev+aspect+slope*CLAY)) # yes, across aspect
summary(mean)
summary(sd)
summary(min)
summary(max)
mean <- with(div, lm(mean~aspect+slope+CLAY*elev)) # yes, across aspect
sd <- with(div, lm(sd~aspect+slope+CLAY*elev)) # yes, across aspect
min <- with(div, lm(min~aspect+slope+CLAY*elev)) # no
max <- with(div, lm(max~aspect+slope+CLAY*elev)) # yes, across aspect
summary(mean)
summary(min)
summary(sd)
summary(max)
mean <- with(div, lm(mean~aspect+CLAY*elev)) # yes, across aspect
with(div, cor(sd, SAND, method = "pearson"))
with(div, cor(sd, SILT, method = "pearson"))
sd <- with(div, lm(sd~aspect+CLAY*elev)) # yes, across aspect
min <- with(div, lm(min~aspect+CLAY*elev)) # no
max <- with(div, lm(max~aspect+CLAY*elev)) # no
summary(mean)
summary(sd)
summary(min)
summary(max)
# Sand, silt, and clay are all closely related because all of the soils at Right Hand Fork are fairly similar kinds
# So, need to chose the one that's most correlated with each temperature variable to include in the model
# It ends up being clay in every case
with(div, cor(mean, SAND, method = "pearson"))
with(div, cor(mean, SILT, method = "pearson"))
with(div, cor(mean, CLAY, method = "pearson"))
with(div, cor(sd, SAND, method = "pearson"))
with(div, cor(sd, SILT, method = "pearson"))
with(div, cor(sd, CLAY, method = "pearson"))
with(div, cor(min, SAND, method = "pearson"))
with(div, cor(min, SILT, method = "pearson"))
with(div, cor(min, CLAY, method = "pearson"))
with(div, cor(max, SAND, method = "pearson"))
with(div, cor(max, SILT, method = "pearson"))
with(div, cor(max, CLAY, method = "pearson"))
mean <- with(div, lm(mean~aspect+elev+SAND+CLAY)) # yes, across aspect
sd <- with(div, lm(sd~aspect+SAND+CLAY)) # yes, across aspect
min <- with(div, lm(min~aspect+elev+SAND+CLAY)) # no
max <- with(div, lm(max~aspect+elev+SAND+CLAY)) # yes across aspect
summary(mean)
sd <- with(div, lm(sd~aspect+SAND+CLAY)) # yes, across aspect
summary(sd)
mean <- with(div, lm(mean~aspect+elev+SAND*CLAY)) # yes - aspect, SAND, CLAY
summary(mean)
summary(sd)
sd <- with(div, lm(sd~aspect+SAND*CLAY)) # yes, across aspect
summary(sd)
min <- with(div, lm(min~aspect+elev+SAND*CLAY)) # no
summary(min)
min <- with(div, lm(min~aspect+elev+SAND+CLAY)) # no
summary(min)
max <- with(div, lm(max~aspect+elev+SAND*CLAY)) # yes across aspect
summary(max)
max <- with(div, lm(max~aspect+elev+SAND+CLAY)) # yes across aspect
summary(max)
mean <- with(div, lm(mean~aspect+elev+SAND+CLAY)) # yes - aspect, SAND, CLAY
sd <- with(div, lm(sd~aspect+SAND+CLAY)) # yes, across aspect
min <- with(div, lm(min~aspect+elev+SAND+CLAY)) # no
max <- with(div, lm(max~aspect+elev+SAND+CLAY)) # yes across aspect
summary(mean)
summary(sd)
summary(min)
summary(max)
mean <- with(div, lm(mean~aspect+elev+SAND*CLAY)) # yes - aspect, SAND, CLAY
sd <- with(div, lm(sd~aspect+SAND*CLAY)) # yes - aspect
min <- with(div, lm(min~aspect+elev+SAND*CLAY)) # no
max <- with(div, lm(max~aspect+elev+SAND*CLAY)) # yes across aspect
summary(mean)
summary(sd)
summary(min)
max <- with(div, lm(max~aspect+elev+SAND*CLAY)) # additive: aspect
summary(max)
with(div, plot(CLAY~elev))
with(div, plot(SAND~elev))
with(div, plot((SAND+CLAY)~elev))
with(div, plot(SAND~CLAY))
with(div, plot(mean~SAND))
with(div, plot(SAND~SILT))
with(div, plot(SAND~CLAY))
with(div, plot(SILT~CLAY))
summary(mean)
summary(sd)
summary(min)
summary(max)
