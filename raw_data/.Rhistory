n <- 3^triads
d <- 100
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(div)
}
# Wavy-linear gradient
wavy.grad <-function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- (i+(Ax*cos(Bx*i)))+(j+(Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x) #completely random variation in x but still deterministic of y
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y) #completely random variation in y
}
}
return(div)
}
# Generate the diversity surfaces for all parameter combinations
make.div <- function(land.gen, params){
div <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
div[,,i] <- with(params, land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i]))
}
return(div)
}
# Generate the diversity surfaces for all parameter combinations
make.div <- function(land.gen, params){
div <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
div[,,i] <- with(params, land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i]))
}
return(div)
}
test.div <- make.div(wavy.grad, test.par)
str(test.div)
test.div[,,1]
# Sample one of those diversity surfaces with a given sampling design
sample.env <- function(div, s.design){
sampled.env <- NA
for(i in seq_len(nrow(s.design))){
for(j in seq_len(nrow(div))){
for(k in seq_len(ncol(div))){
if(s.design[i,1]==j & s.design[i,2]==k){
sampled.env[i] <- div[j,k]
}
}
}
}
return(unlist(sampled.env))
}
test.samp <- sample.env(test.div[,,1],fractal)
# Get sampling points
random <- make.random(n=n, d=d)
fractal <- make.fractal(x=x, y=y, triads=triads, d=d)
grid <- make.grid(n=n,d=d)
transect <- make.transects(n=n, n.transects=n.transects, d=d)
test.samp <- sample.env(test.div[,,1],fractal)
test.samp
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(list(env, div))
}
# Wavy-linear gradient
wavy.grad <-function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- (i+(Ax*cos(Bx*i)))+(j+(Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x) #completely random variation in x but still deterministic of y
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y) #completely random variation in y
}
}
return(list(env, div))
}
#### TESTING THINGS ###
test.par <- data.frame(expand.grid(Ax = seq(0, 10, by=10), Ay = seq(0, 10, by=10),
Bx = seq(0, 0.25, by=0.25), By = seq(0, 0.25, by=0.25),
slope = seq(-2,2, by=4), int = seq(10,20, by=10),
noise.x = 0, noise.y= 0,
d=100))
test.div <- make.div(wavy.grad, test.par) # makes 64 different landscapes
#### TESTING THINGS ###
env.par <- data.frame(expand.grid(Ax = seq(0, 20, by=10), Ay = seq(0, 20, by=10),
Bx = seq(0, 1, by=0.25), By = seq(0, 1, by=0.25),
noise.x = seq(0, 200, 100),
d=d))
div.par <- data.frame(expand.grid(slope = seq(-6,6, by=4), int = seq(10,20, by=10),
noise.y=seq(0, 200, 100)))
str(env.par)
#### TESTING THINGS ###
env.par <- data.frame(expand.grid(Ax = seq(0, 20, by=10), Ay = seq(0, 20, by=10),
Bx = seq(0, 1, by=0.25), By = seq(0, 1, by=0.25),
noise.x = seq(0, 100, 100),
d=d))
nrow(env.par)
#### TESTING THINGS ###
env.par.test <- data.frame(expand.grid(Ax = seq(0, 10, by=10), Ay = seq(0, 10, by=10),
Bx = seq(0, 0.25, by=0.25), By = seq(0, 0.25, by=0.25),
noise.x = seq(0, 100, 100),
d=d))
env.par.test
div.par.test <- data.frame(expand.grid(slope = seq(-6,6, by=4), int = seq(10,10, by=10),
noise.y=seq(0, 100, 100)))
str(div.par.test)
#### TESTING THINGS ###
env.par.test <- data.frame(expand.grid(Ax = seq(0, 10, by=10), Ay = seq(0, 10, by=10),
Bx = seq(0, 0.25, by=0.25), By = seq(0, 0.25, by=0.25),
noise.x = seq(0, 100, 100),
d=d))
test.env <- make.div(wavy.grad, env.par.test) # makes 64 different landscapes
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, d){
env <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
}
}
return(env)
}
# Wavy-linear gradient
wavy.grad <-function(Ax, Ay, Bx, By, noise.x, d){
env <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- (i+(Ax*cos(Bx*i)))+(j+(Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x) #completely random variation in x but still deterministic of y
}
}
return(env)
}
make.env <- function(land.gen, params){
div <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
div[,,i] <- with(params, land.gen(Ax[i], Ay[i], Bx[i], By[i], noise.x[i], d[i]))
}
return(div)
}
test.env <- make.env(wavy.grad, env.par.test) # makes 64 different landscapes
str(test.env)
dim(test.env)
test.env[3]
test.env[[3]]
ncol(test.env)
nrow(env)
nrow(test.env)
str(test.env)
str(test.env[[3]])
str(test.env[,,1:32])
dim(test.env)
dim(test.env)[3]
seq_len(dim(test.env)[3])
nrow(env)
nrow(test.env)
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(list(env, div))
}
#### TESTING THINGS ###
par.test <- data.frame(expand.grid(Ax = seq(0, 10, by=10), Ay = seq(0, 10, by=10),
Bx = seq(0, 0.25, by=0.25), By = seq(0, 0.25, by=0.25),
slope = seq(-6,6, by=4), int = seq(10,10, by=10),
noise.x = seq(0, 100, 100), noise.y=seq(0, 100, 100),
d=d))
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(unlist(env, div))
}
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40,noise.y=20, 100)
test.mtn
str(test.mtn)
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(list(env, div))
}
str(test.mtn)
test.div <- make.div(wavy.grad, test.par) # makes 64 different landscapes
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40,noise.y=20, 100)
str(test.mtn)
test.mtn[1]
str(test.mtn[1])
str(test.mtn[2])
#### TESTING THINGS ###
par.test <- data.frame(expand.grid(Ax = seq(0, 10, by=10), Ay = seq(0, 10, by=10),
Bx = seq(0, 0.25, by=0.25), By = seq(0, 0.25, by=0.25),
slope = seq(-6,6, by=4), int = seq(10,10, by=10),
noise.x = seq(0, 100, 100), noise.y=seq(0, 100, 100),
d=d))
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40,noise.y=20, 100)
str(test.mtn)
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)
str(test.mtn[1])
str(test.mtn[2])
test.div <- test.mtn[2]
test.env <- test.mtn[1]
test.env
str(test.env)
test.env <- unlist(test.mtn[1])
test.div <- unlist(test.mtn[2])
test.env
str(test.env)
test.mtn <- mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)
str(test.mtn)
unlist(test.mtn)
test.env <- as.matrix(unlist(test.mtn[1]))
str(test.env)
d <- 100
test.env <- matrix(unlist(test.mtn[1]),nrow=d,ncol=d)
str(test.env)
test.env <- matrix(test.mtn[1],nrow=d,ncol=d)
str(test.env)
test.env <- matrix(unlist(test.mtn[1]),nrow=d,ncol=d)
str(test.env)
test.div <- matrix(unlist(test.mtn[2]),nrow=d,ncol=d)
test.div
str(test.div)
# for each row of parameters, using a land generation thing
test.mtn <- matrix(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]),nrow=d,nrow=d)
mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]
str(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1])
unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1])
str(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]))
# for each row of parameters, using a land generation thing
str(matrix(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]),nrow=d,nrow=d))
# for each row of parameters, using a land generation thing
str(matrix(unlist(mtn(10, 20, 0.2, 0.3, 5, 30, noise.x=40, noise.y=20, 100)[1]),nrow=d,ncol=d))
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <- with(params, matrix(unlist(land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1]), nrow=d[i], ncol=d[i]))
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1])), nrow=d[i], ncol=d[i])
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
# Mountainous
mtn <- function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- ((Ax*cos(Bx*i)))+((Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x)
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y)
}
}
return(list(env, div))
}
# Wavy-linear gradient
wavy.grad <-function(Ax, Ay, Bx, By, slope, int, noise.x, noise.y, d){
env <- matrix(nrow=d, ncol=d)
div <- matrix(nrow=d, ncol=d)
for (i in seq_len(d)){
for (j in seq_len(d)){
env[i,j] <- (i+(Ax*cos(Bx*i)))+(j+(Ay*cos(By*j))) + rnorm(1,mean=0,sd=noise.x) #completely random variation in x but still deterministic of y
div[i,j] <- slope*env[i,j] + int + rnorm(1,mean=0,sd=noise.y) #completely random variation in y
}
}
return(list(env, div))
}
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1])), nrow=d[i], ncol=d[i])
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
sample.env <-
make.env <- function(land.gen, params){
env <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
env[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[1])), nrow=d, ncol=d)
}
return(env)
}
test.mult.env <- make.env(wavy.grad, par.test)
str(test.mult.env)
par.test
str(par.test)
make.div <- function(land.gen, params){
div <- array(dim=c(d, d, nrow(params)))
for (i in seq_len(nrow(params))){
div[,,i] <-  matrix(unlist(with(params,land.gen(Ax[i], Ay[i], Bx[i], By[i], slope[i], int[i], noise.x[i], noise.y[i], d[i])[2])), nrow=d, ncol=d)
}
return(div)
}
test.mult.div <- make.div(wavy.grad, par.test)
str(test.mult.div)
str(test.mult.env)
str(params)
str(test.params)
str(test.par)
str(par.test)
mtn.coefs <- c(2.2945, 2.2945+0.0004, 2.2945+0.0031, 2.2945+1.6629, 2.2945+0.4519, 2.2945+0.0482, 2.2945-3.9247, 2.2945+2.2516, 2.2945+0.1675, 2.2945+0.0433, 2.2945-0.1026)
# function for making each coefficient in logistic regression output a proportion
inv.logit <- function(x) exp(x)/(exp(x)+1)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
mtn.coefs <- c(2.7027, 2.7027+0.0038, 2.7027-0.0140, 2.7027-0.2396, 2.7027+1.8768, 2.7027+0.0133, 2.7027-2.0104, 2.7027+0.5291, 2.7027+0.0365, 2.7027-0.1722, 2.7027-0.1722)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
mtn.coefs <- c(2.4881, 2.4881-0.0007, 2.4881+0.0107, 2.4881-0.9970, 2.4881+0.1068, 2.4881-0.0147, 2.4881-3.6243, 2.4881+2.5654, 2.4881+0.0072, 2.4881-0.0647, 2.4881-0.2890)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
mtn.coefs <- c(3.0177, 3.0177-0.0010, 3.0177-0.0127, 3.0177-1.0939, 3.0177-1.0747, 3.0177-0.0000, 3.0177-1.9250, 3.0177+0.9692, 3.0177+0.0331, 3.0177-0.2573, 3.0177-0.2573)
inv.mtn.coefs <- inv.logit(mtn.coefs)
inv.mtn.coefs
2916*2
###########
# HEADERS #
###########
library(pez)
library(vegan)
library(lme4)
library(visreg) # need to load this package to plot loaded .Rdata
?.ses.mpd
library(rstanarm)
citation(rstanarm)
?citation
citation("rstanarm")
citation("vegan")
dljfsldfs
dkfjdk'fjdsl'
?cortest
??cortest
?cor.test
setwd("~/Documents/projects/functional_traits_rhf/raw_data")
d.eight <- read.csv("rhf_2018_cover.csv", as.is = true)
d.eight <- read.csv("rhf_2018_cover.csv", as.is = TRUE)
head(d.eight)
d.nige <- read.csv("rhf_2019_cover.csv, as.is=TRUE")
d.nige <- read.csv("rhf_2019_cover.csv, as.is=TRUE)
d.nine <- read.csv("rhf_2019_cover.csv", as.is=TRUE)
d.nine <- read.csv("rhf_2019_cover.csv", as.is=TRUE)
head(d.nine)
cover.eight$Cover.over <- NA
for (i in seq_len(nrow(cover.eight))){
if (with(cover.eight, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover.eight, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover.eight$Cover.over[i] <- cover.eight$Cover[i]
}
}
cover.eight$Cover.over <- NA
for (i in seq_len(nrow(cover.eight))){
if (with(cover.eight, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover.eight, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover.eight$Cover.over[i] <- cover.eight$Cover[i]
}
}
calc.over <- function(cover){
cover$Cover.over <- NA
for (i in seq_len(nrow(cover))){
if (with(cover, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover$Cover.over[i] <- cover$Cover[i]
}
}
}
eight.over <- calc.over(d.eight)
head(eight.over)
head(cover)
head(d.eight)
calc.over <- function(cover){
cover$Cover.over <- NA
for (i in seq_len(nrow(cover))){
if (with(cover, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover$Cover.over[i] <- cover$Cover[i]
}
}
reture(cover)
}
eight.over <- calc.over(d.eight)
return(cover)
calc.over <- function(cover){
cover$Cover.over <- NA
for (i in seq_len(nrow(cover))){
if (with(cover, grepl("overhang-", Notes[i]))){
cover$Cover.over[i] <- with(cover, Cover[i] + as.numeric(unlist(regmatches(Notes[i], gregexpr('\\(?[0-9,.]+', Notes[i])))))
} else {
cover$Cover.over[i] <- cover$Cover[i]
}
}
return(cover)
}
eight.over <- calc.over(d.eight)
head(eight.over)
nine.over <- calc.over(d.nine)
nine.over
head(nine.over)
calc.comm <- function(cover){
comm <- with(cover, tapply(Cover.over, list(Plot_id,Species), function(x) mean(x,na.rm=TRUE)))
comm[is.na(comm)] <- 0
comm <- comm[, colSums(comm != 0) > 0]
comm <- comm[,!grepl("^[a-z]+", colnames(comm))]
comm <- comm[,!grepl("\\(|/", colnames(comm))]
comm <- comm[,!grepl("sp\\.", colnames(comm))]
colnames(comm) <- tolower(colnames(comm))
return(comm)
}
eight.comm <- calc.comm(eight.over)
head(eight.comm)
head(eight.over)
setdiff(eight.over$Plot_id, nine.over$Plot_id)
setdiff(nine.over$Plot_id, eight.over$Plot_id)
intersect(nine.over$Plot_id, eight.over$Plot_id)
length(intersect(nine.over$Plot_id, eight.over$Plot_id))
eight.core <- eight.over[eight.over$Plot_id %in% nine.over$Plot_id,]
# Calcualte cover, including overhang, for all plots surveyed in 2018 and 2019
tot.eight <- calc.over(d.eight)
tot.nine <- calc.over(d.nine)
# Subset the 2018 data to the core plots also surveyed in 2019
core.eight <- tot.eight[tot.eight$Plot_id %in% tot.nine$Plot_id,]
length(unique(core.eight$Plot_id))
# Do analyses across topography for each of these and generate plots to include in the supp.
int.eight.comm <- calc.comm(int.eight)
# Calculate cover, including overhang, for all plots surveyed in 2018 and 2019
int.eight <- calc.over(d.eight)
core.nine <- calc.over(d.nine)
# Subset the 2018 data to the core plots also surveyed in 2019
core.eight <- int.eight[int.eight$Plot_id %in% int.nine$Plot_id,]
# Do analyses across topography for each of these and generate plots to include in the supp.
int.eight.comm <- calc.comm(int.eight)
core.nine.comm <- calc.comm(core.nine)
# Subset the 2018 data to the core plots also surveyed in 2019
core.eight <- int.eight[int.eight$Plot_id %in% core.nine$Plot_id,]
# Do analyses across topography for each of these and generate plots to include in the supp.
int.eight.comm <- calc.comm(int.eight)
core.nine.comm <- calc.comm(core.nine)
core.eight.comm <- calc.comm(core.eight)
head(core.nine.comm)
str(core.nine.comm)
colnames(core.nine.comm[1,]>0)
core.nine.comm$1111>0
core.nine.comm$1111
core.nine.comm$1111[1,]
core.nine.comm[1,]
core.nine.comm[1,]>0
names(core.nine.comm[1,]>0)
colnames(core.nine.comm[1,])
colnames(core.nine.comm[1,]>0)
colnames(core.nine.comm[1,]>0==TRUE)
core.nine.comm[1,]>0
if(core.nine.comm[1,]>0)
# Checking between the core plot
colnames(core.nine.comm)
str(core.nine.comm)
colnames(core.nine.comm)
# Checking between the core plots
setdiff(colnames(core.nine.comm), colnames(core.eight.comm))
# [1] "agoseris glauca"          "agoseris grandiflora"
# [3] "arabis nuttallii"         "astragalus cibarius"
# [5] "boechera divaricarpa"     "delphinium nuttallianum"
# [7] "epilobium angustifolium " "erysimum capitatum"
# [9] "eucephalus engelmannii "  "hydrophyllum capitatum"
# [11] "phacelia linearis"        "silene menziesii"
# [13] "triteleia grandiflora"    "viola nuttallii"
setdiff(colnames(core.eight.comm), colnames(core.nine.comm))
